"""
Первая библиотека, которая меня заинтересовала - matplotlib.

Возможности matplotlib:

- Построение различных типов графиков: линейные, столбчатые, круговые, гистограммы и многие другие.
- Настройка графиков: изменение цветов, меток, легенд, шрифтов и стилей линий.
- Работа с осями: возможность задавать разные шкалы и выбирать диапазоны отображения.
"""
# 1. Линейный график
import matplotlib.pyplot as plt

# Данные
x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]

# Создание линейного графика
plt.plot(x, y, marker='o')
plt.title('Линейный график')
plt.xlabel('X')
plt.ylabel('Y')
plt.grid(True)

# Показать график
plt.show()

# 2. Столбчатая диаграмма

# Данные
categories = ['A', 'B', 'C', 'D']
values = [3, 7, 4, 6]

# Создание столбчатой диаграммы
plt.bar(categories, values, color='green')
plt.title('Столбчатая диаграмма')
plt.xlabel('Категории')
plt.ylabel('Значения')

# Показать график
plt.show()

# 3. Гистограмма

# Генерация случайных данных
import numpy as np

data = np.random.randn(1000)

# Создание гистограммы
plt.hist(data, bins=500, color='black', alpha=0.7)
plt.title('Гистограмма')
plt.xlabel('Значение')
plt.ylabel('Частота')

# Показать график
plt.show()

"""
Вторая библиотека - pillow.
Кстати, она уже загрузилась при установке matplotlib. Версия 11. Я её просто обновил, хоть это и не требовалось.

Основные возможности pillow:

- Открытие и сохранение изображений: Поддерживает множество форматов изображений, включая JPEG, PNG, GIF, BMP и TIFF.
- Возможности изменения размеров, обрезки, поворота, зеркального отображения и сжатия изображений.
- Применение различных фильтров, таких как размытие, резкость и преобразование в градации серого.
- Прямой доступ к данным пикселей для их изменения, анализа или обработки.
- Возможность наложения текста, линий и других графических элементов на изображение.
- Поддержка анимационных форматов, таких как GIF, включая создание и изменение анимаций.
- Работа с прозрачностью и слоями для создания сложных изображений.
"""
# Попробовал реализовать программу по удалению белого фона с изображения. Получилось не очень. Если цвет даже чуть-чуть
# отличается, программа его не удаляет. Потом думаю подшаманю, мне в презентациях на текущей работе часто нужно удалять
# фон на фото.

from PIL import Image

def remove_background(input_image_path, output_image_path, bg_color=(255, 255, 255)):
    # Открытие изображения
    image = Image.open(input_image_path).convert("RGBA")

    # Создаем новое изображение с прозрачным фоном
    new_image = Image.new("RGBA", image.size)

    # Проход по каждому пикселю изображения
    for x in range(image.width):
        for y in range(image.height):
            # Получаем цвет пикселя
            pixel = image.getpixel((x, y))

            # Проверяем, является ли пиксель цветом фона
            if pixel[:3] == bg_color:  # Сравниваем только RGB
                new_image.putpixel((x, y), (255, 255, 255, 0))  # Делает пиксель прозрачным
            else:
                new_image.putpixel((x, y), pixel)  # Сохраняет пиксель без изменений

    # Сохранение нового изображения
    new_image.save(output_image_path, format="PNG")


# Пример использования
remove_background("Лого_Вертикальный.jpg", "Лого_Вертикальный.png",
                  bg_color=(255, 255, 255))  # Указать цвет фона



# Еще стало интересно как увеличить четкость изображения. Бывает, что на просторах интернета подходящее фото для
# презентации нужно большего размера, при растягивании в PowerPoint теряется четкость. Попробовал это сделать.

from PIL import Image, ImageFilter

def sharpen_image(input_image_path, output_image_path):
    # Открытие изображения
    image = Image.open(input_image_path)

    # Применение фильтра резкости
    sharpened_image = image.filter(ImageFilter.SHARPEN)

    # Сохранение нового изображения
    sharpened_image.save(output_image_path)

# Пример использования
sharpen_image("Лес4.jpg", "Лес2.jpg")

# Функция выше оказалось не даёт возможности регулировать четкость (резкость), а повторное использование на уже
# измененном изображении не работает. Нашёл класс UnsharpMask. Попробовал использовать. Оказалось нужно либо хорошо
# разбираться в фотошопе, либо долго пробовать разные значения. Тоже можно в принципе использовать.

def sharpen_image_with_unsharp_mask(input_image_path, output_image_path, radius=2, percent=150, threshold=3):
    # Открытие изображения
    image = Image.open(input_image_path)

    # Применение фильтра UnsharpMask
    sharpened_image = image.filter(ImageFilter.UnsharpMask(radius=radius, percent=percent, threshold=threshold))

    # Сохранение нового изображения
    sharpened_image.save(output_image_path)


# Пример использования
sharpen_image_with_unsharp_mask("Лес.jpg", "Лес3.jpg", radius=1, percent=300, threshold=3)

"""
Третья библиотека - python-pptx.
Решил изучить, что-то что может помочь на текущей работе и дальше. Вспомнил, что иногда нужно поменять шрифт в 
презентации, например, с Calibri на Tahoma. Если делать новую презентацию, это можно настроить заранее. А вот если мне 
прислали не мою, и нужно исправить...Это можно сделать с помощью данной библиотеки.

Еще возможности python-pptx:
- Позволяет создавать новые презентации и изменять существующие.
- Возможность добавления новых слайдов в презентацию с использованием различных макетов.
- Позволяет добавлять текстовые блоки на слайды, а также изменять шрифты, размеры, цвета и стили текста.
- Поддержка вставки изображений (например, в форматах PNG, JPEG и GIF) на слайды.
- Возможность добавления таблиц с настройкой количества строк и столбцов, а также форматирования текста внутри ячеек.
- Поддержка добавления графиков и диаграмм для визуализации данных.
- Работа с темами и стилями слайдов, включая изменение фона, цветовой палитры и других элементов дизайна.
- Сохранение изменений в формате .pptx и экспорт слайдов в другие форматы.
- Возможность добавления и настройки различных графических элементов, таких как линии, фигуры, закладки и т. д.
- Возможность настройки анимаций объектов и переходов между слайдами (хотя функции анимации могут быть ограничены).

К сожалению, больше что-то нужное не нашел в этой библиотеке. Остальное (то, что мне необходимо) нужно делать напрямую
в PowerPoint.
"""

# Реализовал изменение шрифта.

from pptx import Presentation

def change_font_in_presentation(pptx_path, new_font_name):
    # Открываем презентацию
    prs = Presentation(pptx_path)

    # Проходим по всем слайдам
    for slide in prs.slides:
        # Проходим по всем фигурам на слайде
        for shape in slide.shapes:
            # Если фигура имеет текстовое содержимое
            if hasattr(shape, "text_frame"):
                for paragraph in shape.text_frame.paragraphs:
                    for run in paragraph.runs:
                        run.font.name = new_font_name  # Устанавливаем новый шрифт

    # Сохраняем изменения в новой презентации
    prs.save("Гайд по развитию компетенций_V6.pptx")

# Пример использования
change_font_in_presentation("Гайд по развитию компетенций_V5.pptx", "Times New Roman")

"""
Четвертая библиотека - NumPy.
Взял еще одну библиотеку, т.к. подумал, что математические операции точно пригодятся.

Возможности NumPy:
- Основным объектом в NumPy является многоразмерный массив (ndarray), который позволяет хранить данные в одном или 
нескольких измерениях.
- NumPy позволяет выполнять операции над массивами без использования циклов, что значительно ускоряет вычисления. 
Например, арифметические операции могут применяться к целым массивам.
- В библиотеке есть множество встроенных математических функций для выполнения операций, таких как `sin`, `cos`, `exp`,
`log` и многие другие.
- NumPy предоставляет функции для выполнения различных операций линейной алгебры: вычисление детерминантов, следов, 
обратных матриц, решения систем линейных уравнений и т.д.
- Библиотека включает полезные функции для вычисления статистических характеристик, таких как среднее, медиана, мода, 
стандартное отклонение и корреляция.
- NumPy позволяет изменять размер, обрезать, объединять или разделять массивы. Это делает работу с данными более гибкой.
- Поддерживаются сложные операции индексации и срезов, что позволяет извлекать и изменять определенные элементы или 
подмассивы.
"""
# 1. Создаем одномерный и двумерный массив, а также выполняем простую арифметическую операцию — возводим элементы
# одномерного массива в квадрат.

import numpy as np

# Создание одномерного массива
arr = np.array([1, 2, 3, 4, 5])
print("Одномерный массив:", arr)

# Выполнение арифметической операции
squared = arr ** 2
print("Квадраты элементов массива:", squared)

# Создание двумерного массива
matrix = np.array([[1, 2, 3], [4, 5, 6]])
print("Двумерный массив:\n", matrix)

# 2. Генерируем массив случайных чисел и вычисляем их среднее, медиану и стандартное отклонение

# Создание массива случайных чисел
data = np.random.randint(1, 101, size=10)  # 10 случайных целых чисел от 1 до 100
print("Случайные числа:", data)

# Вычисление статистических показателей
mean_value = np.mean(data)
median_value = np.median(data)
std_dev = np.std(data)

print("Среднее:", mean_value)
print("Медиана:", median_value)
print("Стандартное отклонение:", std_dev)

# 3. Выполняем операции сложения и умножения матриц, а также вычисляем обратную матрицу

# Определение двумерных массивов (матриц)
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# Сложение матриц
C = A + B
print("Сложение матриц:\n", C)

# Умножение матриц
D = np.dot(A, B)  # или A @ B в альтернативной записи
print("Умножение матриц:\n", D)

# Вычисление обратной матрицы
A_inv = np.linalg.inv(A)
print("Обратная матрица A:\n", A_inv)


